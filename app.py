"""
app.py
------
Streamlit UI â€” thin interface only.
All computation is delegated to engine/ modules.
All plots are generated by visuals/ modules.
"""

import streamlit as st
import pandas as pd
import numpy as np
import io
import os
import sys
import joblib

# â”€â”€ Make engine/ and visuals/ importable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sys.path.insert(0, os.path.dirname(__file__))

# â”€â”€ Engine imports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from engine.data_loader        import load_csv, train_test_split, get_available_vars
from engine.feature_engineering import build_features, get_feature_cols
from engine.ml_model           import train_xgboost, save_model, load_model, predict
from engine.forecast           import recursive_forecast, build_forecast_dataframe
from engine.metrics            import compute_metrics, compute_residual_stats
from engine.hydraulics         import rational_method_summary
from engine.channel_design     import design_rectangular, design_trapezoidal
from engine.risk_assessment    import compute_flood_risk, get_ml_peak_discharge

# â”€â”€ Visual imports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from visuals.plots           import (
    plot_timeseries_overview, plot_actual_vs_predicted,
    plot_scatter, plot_residuals, plot_feature_importance,
    plot_forecast, plot_flood_risk,
)
from visuals.channel_sections import plot_channel_sections

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PAGE CONFIG
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
st.set_page_config(
    page_title="Rainfallâ€“Runoff Decision Support System",
    layout="wide",
    page_icon="ğŸŒ§ï¸",
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SESSION STATE HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def _state(key, default=None):
    if key not in st.session_state:
        st.session_state[key] = default
    return st.session_state[key]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SIDEBAR â€” INPUTS ONLY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
with st.sidebar:
    st.title("âš™ï¸ Control Panel")

    st.header("ğŸ“‚ Data")
    uploaded = st.file_uploader(
        "Upload processed CSV (date index, rainfall, discharge, â€¦)",
        type=["csv"],
        help="CSV must have a 'date' column as index with rainfall and discharge columns.",
    )

    st.divider()
    st.header("ğŸ¤– ML Model")
    retrain = st.button("ğŸ”„ Train / Retrain XGBoost", type="primary",
                         help="Trains XGBoost for rainfall and discharge targets using TimeSeriesSplit CV.")
    n_iter_cv = st.slider("RandomizedSearchCV iterations", 5, 50, 20, step=5)

    st.divider()
    st.header("ğŸ”® Forecast")
    n_forecast_months = st.slider("Forecast horizon (months)", 3, 24, 12)

    st.divider()
    st.header("ğŸ—ï¸ Hydraulic Design")
    with st.expander("Catchment Parameters", expanded=True):
        L_m       = st.number_input("Flow path length L (m)",      100, 10000, 2500)
        S_catch   = st.number_input("Catchment slope S (m/m)",     0.001, 0.5, 0.02, format="%.4f")
        C_runoff  = st.number_input("Runoff coefficient C",        0.1, 1.0, 0.75, format="%.2f")
        A_catch   = st.number_input("Catchment area A (kmÂ²)",      0.1, 100.0, 0.5, format="%.2f")
        A_idf_val = st.number_input("IDF constant A (Ikeja 10-yr)", 100, 20000, 8266)
        B_idf_val = st.number_input("IDF constant B",               1, 200, 63)
    with st.expander("Channel Parameters", expanded=True):
        n_mann  = st.number_input("Manning's n",          0.005, 0.1, 0.015, format="%.4f")
        S_ch    = st.number_input("Channel bed slope S",  0.0001, 0.05, 0.002, format="%.5f")
        z_slope = st.number_input("Trapezoidal side slope z (H:V)", 0.5, 3.0, 1.0, format="%.1f")

    st.divider()
    st.caption("âš ï¸ ML discharge is **never** used to size channels. "
               "Design is based on Rational Method + IDF only.")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOAD DATA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
df_raw = None
if uploaded is not None:
    try:
        df_raw = load_csv(uploaded)
        st.session_state['df_raw'] = df_raw
    except Exception as e:
        st.error(f"Failed to load CSV: {e}")
elif 'df_raw' in st.session_state:
    df_raw = st.session_state['df_raw']

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HEADER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
st.title("ğŸŒ§ï¸ Rainfallâ€“Runoff Forecasting & Hydraulic Channel Design")
st.markdown(
    "> **Decision-Support Engineering System** | "
    "ML enhances hydrological insight â€” channel sizing follows standards-based hydraulics only."
)

if df_raw is None:
    st.info(
        "ğŸ‘ˆ Upload your processed CSV file from the sidebar to get started. "
        "The file should contain a **date** index with **rainfall** and **discharge** columns."
    )
    st.stop()

# â”€â”€ Feature engineering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@st.cache_data(show_spinner="Building featuresâ€¦")
def get_featured(df):
    return build_features(df)

df_feat = get_featured(df_raw)
train_df, test_df = train_test_split(df_feat)
vars_present = get_available_vars(df_raw)

# â”€â”€ Train / load models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TARGETS = ['rainfall', 'discharge']
MODEL_DIR = os.path.join(os.path.dirname(__file__), 'saved_models')

if retrain:
    with st.spinner("Training XGBoost (this may take a minute)â€¦"):
        for tgt in TARGETS:
            try:
                model, feats, metrics = train_xgboost(
                    train_df, test_df, tgt, n_iter=n_iter_cv
                )
                os.makedirs(MODEL_DIR, exist_ok=True)
                save_model(model, os.path.join(MODEL_DIR, f'xgb_{tgt}.pkl'))
                joblib.dump(feats, os.path.join(MODEL_DIR, f'feats_{tgt}.pkl'))
                joblib.dump(metrics, os.path.join(MODEL_DIR, f'metrics_{tgt}.pkl'))
                st.session_state[f'model_{tgt}']   = model
                st.session_state[f'feats_{tgt}']   = feats
                st.session_state[f'metrics_{tgt}'] = metrics
            except Exception as e:
                st.error(f"Training failed for {tgt}: {e}")
    st.success("âœ… Models trained and saved.")

# Auto-load from disk if not in session
for tgt in TARGETS:
    if f'model_{tgt}' not in st.session_state:
        mpath = os.path.join(MODEL_DIR, f'xgb_{tgt}.pkl')
        fpath = os.path.join(MODEL_DIR, f'feats_{tgt}.pkl')
        mpath2 = os.path.join(MODEL_DIR, f'metrics_{tgt}.pkl')
        if os.path.exists(mpath):
            st.session_state[f'model_{tgt}']   = load_model(mpath)
            st.session_state[f'feats_{tgt}']   = joblib.load(fpath)
            st.session_state[f'metrics_{tgt}'] = joblib.load(mpath2)

models_ready = all(f'model_{t}' in st.session_state for t in TARGETS)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HYDRAULIC COMPUTATIONS (always run â€” no ML dependency)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
hydro_summary = rational_method_summary(
    L=L_m, S_catch=S_catch, C=C_runoff, A_km2=A_catch,
    A_idf=A_idf_val, B_idf=B_idf_val,
)
Q_design = hydro_summary['Q_rational']
rect_design = design_rectangular(Q_design, n_mann, S_ch)
trap_design  = design_trapezoidal(Q_design, n_mann, S_ch, z_slope)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TABS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tab_val, tab_fore, tab_ch, tab_risk = st.tabs([
    "ğŸ“Š Model Validation",
    "ğŸ”® Forecast",
    "ğŸ—ï¸ Channel Design",
    "âš ï¸ Flood Risk Assessment",
])

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TAB 1: MODEL VALIDATION
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
with tab_val:
    st.header("Model Validation â€” XGBoost")
    st.caption(
        "Trained on 80% of data (temporal split). Evaluated on the remaining 20%. "
        "No future data leaks into training via TimeSeriesSplit cross-validation."
    )

    if not models_ready:
        st.warning("No trained model found. Click **Train / Retrain XGBoost** in the sidebar.")
        st.stop()

    for tgt in TARGETS:
        model   = st.session_state[f'model_{tgt}']
        feats   = st.session_state[f'feats_{tgt}']
        metrics = st.session_state[f'metrics_{tgt}']
        y_actual = metrics['test_actual']
        y_pred   = metrics['test_predicted']
        rmse     = metrics['rmse']
        r2       = metrics['r2']

        with st.expander(f"ğŸ“Œ {tgt.title()} â€” Metrics", expanded=True):
            c1, c2, c3, c4 = st.columns(4)
            c1.metric("RMSE",      f"{rmse:.4f}")
            c2.metric("MAE",       f"{metrics['mae']:.4f}")
            c3.metric("RÂ²",        f"{r2:.4f}")
            c4.metric("CV RMSE",   f"{metrics.get('cv_rmse', 0):.4f}")

            st.subheader("Actual vs Predicted")
            fig_avp = plot_actual_vs_predicted(
                test_df.index[:len(y_actual)], y_actual, y_pred, rmse, r2, tgt
            )
            st.pyplot(fig_avp)
            plt = __import__('matplotlib.pyplot', fromlist=['close'])
            plt.close(fig_avp)

            col_a, col_b = st.columns(2)
            with col_a:
                st.subheader("Scatter Diagnostic")
                fig_sc = plot_scatter(y_actual, y_pred, r2, tgt)
                st.pyplot(fig_sc)
                plt.close(fig_sc)

            with col_b:
                st.subheader("Feature Importance")
                fig_fi = plot_feature_importance(metrics['feature_importances'], tgt)
                st.pyplot(fig_fi)
                plt.close(fig_fi)

            st.subheader("Residual Analysis")
            fig_res = plot_residuals(
                test_df.index[:len(y_actual)],
                y_actual, y_pred,
                metrics['train_actual'], metrics['train_predicted'],
                tgt,
            )
            st.pyplot(fig_res)
            plt.close(fig_res)

    # EDA overview
    with st.expander("ğŸ“ˆ EDA â€” All Variables Time Series"):
        fig_ts = plot_timeseries_overview(df_raw, vars_present)
        st.pyplot(fig_ts)
        import matplotlib.pyplot as mplt
        mplt.close(fig_ts)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TAB 2: FORECAST
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
with tab_fore:
    st.header("12-Month Recursive Forecast")
    st.caption(
        "Forecast is generated recursively: each predicted value feeds back as a "
        "lag feature for subsequent steps. Uncertainty is represented by Â±1 RMSE band."
    )

    if not models_ready:
        st.warning("Train the model first.")
        st.stop()

    run_forecast = st.button("â–¶ï¸ Generate Forecast", type="primary")

    if run_forecast or 'forecast_df' in st.session_state:
        if run_forecast:
            with st.spinner("Running recursive forecastâ€¦"):
                fc_series = {}
                for tgt in TARGETS:
                    model  = st.session_state[f'model_{tgt}']
                    feats  = st.session_state[f'feats_{tgt}']
                    fc_series[tgt] = recursive_forecast(
                        model, df_feat, feats, tgt, n_months=n_forecast_months
                    )
                forecast_df = build_forecast_dataframe(
                    fc_series['rainfall'], fc_series['discharge']
                )
                st.session_state['forecast_df']     = forecast_df
                st.session_state['forecast_series'] = fc_series

        forecast_df    = st.session_state['forecast_df']
        fc_series      = st.session_state['forecast_series']

        for tgt in TARGETS:
            rmse   = st.session_state[f'metrics_{tgt}']['rmse']
            hist   = df_raw[tgt].last('36M') if hasattr(df_raw[tgt], 'last') else df_raw[tgt].iloc[-36:]
            fig_fc = plot_forecast(hist, fc_series[tgt], rmse, tgt)
            st.pyplot(fig_fc)
            import matplotlib.pyplot as mplt
            mplt.close(fig_fc)

        st.subheader("Forecast Table")
        st.dataframe(forecast_df.round(3), use_container_width=True)

        # Download
        csv_bytes = forecast_df.to_csv().encode('utf-8')
        st.download_button(
            label="â¬‡ï¸ Download Forecast CSV",
            data=csv_bytes,
            file_name="forecast.csv",
            mime="text/csv",
        )

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TAB 3: CHANNEL DESIGN
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
with tab_ch:
    st.header("Hydraulic Channel Design")

    st.warning(
        "âš ï¸ **ENGINEERING PRINCIPLE (NON-NEGOTIABLE):** "
        "Channel sizing uses **Q_rational from IDF** only. "
        "ML discharge is **never** used for structural design."
    )

    # IDF / Rational Method summary
    with st.expander("ğŸ”¢ Rational Method Calculations", expanded=True):
        c1, c2, c3, c4 = st.columns(4)
        c1.metric("Tc (min)",    f"{hydro_summary['Tc_min']:.2f}")
        c2.metric("i IDF (mm/hr)", f"{hydro_summary['i_idf']:.2f}")
        c3.metric("Q_rational (mÂ³/s)", f"{Q_design:.4f}")
        c4.metric("C Ã— A (kmÂ²)", f"{C_runoff * A_catch:.4f}")
        st.caption(
            f"IDF: i = {A_idf_val} / (Tc + {B_idf_val}) = {hydro_summary['i_idf']:.2f} mm/hr  |  "
            f"Q = 0.278 Ã— {C_runoff} Ã— {hydro_summary['i_idf']:.2f} Ã— {A_catch} = **{Q_design:.4f} mÂ³/s**"
        )

    # Cross-section plots
    fig_cs = plot_channel_sections(
        rect_design, trap_design, Q_design, n_mann, S_ch, C_runoff, A_catch
    )
    st.pyplot(fig_cs)
    import matplotlib.pyplot as mplt
    mplt.close(fig_cs)

    # Results table
    st.subheader("Design Summary Table")
    params = [
        'Q_design (mÂ³/s)', 'y â€” Flow Depth (m)', 'b â€” Bottom Width (m)',
        'z â€” Side Slope',  'A â€” Cross-section Area (mÂ²)',
        'P â€” Wetted Perimeter (m)', 'R â€” Hydraulic Radius (m)',
        'V â€” Flow Velocity (m/s)', 'Velocity Check',
        'F â€” Freeboard (m)', 'Y_total â€” Total Depth (m)',
    ]
    rect_vals = [
        f"{rect_design['Q_design']:.4f}", f"{rect_design['y']:.4f}",
        f"{rect_design['b']:.4f}", "0 (vertical)",
        f"{rect_design['A']:.4f}", f"{rect_design['P']:.4f}",
        f"{rect_design['R']:.4f}", f"{rect_design['V']:.4f}",
        rect_design['velocity_status'],
        f"{rect_design['F']:.4f}", f"{rect_design['Y_total']:.4f}",
    ]
    trap_vals = [
        f"{trap_design['Q_design']:.4f}", f"{trap_design['y']:.4f}",
        f"{trap_design['b']:.4f}", f"{z_slope} (45Â° for z=1)",
        f"{trap_design['A']:.4f}", f"{trap_design['P']:.4f}",
        f"{trap_design['R']:.4f}", f"{trap_design['V']:.4f}",
        trap_design['velocity_status'],
        f"{trap_design['F']:.4f}", f"{trap_design['Y_total']:.4f}",
    ]
    design_table = pd.DataFrame({
        'Parameter':    params,
        'Rectangular':  rect_vals,
        'Trapezoidal':  trap_vals,
    }).set_index('Parameter')
    st.table(design_table)

    # Manning's verification box
    st.info(
        f"**Manning's Equation:**  Q = (1/n) Ã— A Ã— R^(2/3) Ã— S^(1/2)\n\n"
        f"Rectangular â†’ Q = (1/{n_mann}) Ã— {rect_design['A']:.4f} Ã— "
        f"{rect_design['R']:.4f}^(2/3) Ã— {S_ch}^(1/2) â‰ˆ **{Q_design:.4f} mÂ³/s** âœ…"
    )

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TAB 4: FLOOD RISK ASSESSMENT
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
with tab_risk:
    st.header("Flood Risk Assessment")

    st.error(
        "ğŸš¨ **CRITICAL NOTICE TO ENGINEERS:** The ML-derived discharge presented here "
        "represents **basin-scale hydrological behaviour** observed at a river gauge station "
        "covering a much larger upstream catchment than the local 0.5 kmÂ² design area. "
        "It must **never** be substituted for the rational method design discharge in "
        "channel sizing calculations."
    )

    if not models_ready:
        st.warning("Train the model first to view flood risk assessment.")
        st.stop()

    # Compute Q_ML from discharge model predictions
    disc_metrics = st.session_state['metrics_discharge']
    Q_ml = get_ml_peak_discharge(
        disc_metrics['test_actual'],
        disc_metrics['test_predicted'],
        percentile=95.0,
    )

    risk = compute_flood_risk(Q_ml, Q_design)

    # Risk banner
    risk_color_map = {
        'EXTREME': 'error', 'VERY HIGH': 'error',
        'HIGH': 'warning', 'MODERATE': 'info',
    }
    banner = getattr(st, risk_color_map.get(risk['risk_level'], 'warning'))
    banner(
        f"**Flood Risk Level: {risk['risk_level']}**  |  "
        f"Safety Factor: {risk['safety_factor']:.1f}Ã—  |  "
        f"Q_ML = {Q_ml:.4f} mÂ³/s  vs  Q_design = {Q_design:.4f} mÂ³/s"
    )

    # Comparison chart
    fig_risk = plot_flood_risk(Q_ml, Q_design,
                                risk['safety_factor'], risk['risk_level'])
    st.pyplot(fig_risk)
    import matplotlib.pyplot as mplt
    mplt.close(fig_risk)

    # Metrics row
    c1, c2, c3 = st.columns(3)
    c1.metric("Q_rational (design)", f"{Q_design:.4f} mÂ³/s",
              help="From IDF + rational method. Used for channel sizing.")
    c2.metric("Q_ML (95th pct)", f"{Q_ml:.4f} mÂ³/s",
              help="XGBoost 95th percentile discharge. Basin-scale indicator only.")
    c3.metric("Overdesign Factor", f"{risk['safety_factor']:.1f}Ã—",
              help="Ratio Q_ML / Q_rational. Indicates catchment vulnerability.")

    # Interpretation
    st.subheader("Engineering Interpretation")
    st.markdown(risk['interpretation'])

    st.subheader("Recommendation")
    st.markdown(risk['recommendation'])

    # Scale clarification
    with st.expander("ğŸ“ Why is Q_ML so much larger than Q_design?"):
        st.markdown("""
**This is expected and physically correct.** The two discharges represent fundamentally different phenomena:

| Aspect | Q_rational (design) | Q_ML (flood indicator) |
|--------|--------------------|-----------------------|
| **Scale** | Local catchment (0.5 kmÂ²) | River gauge basin (much larger) |
| **Method** | IDF + Rational equation | XGBoost trained on historical gauge data |
| **Purpose** | Size the drainage channel | Understand basin-scale flood risk |
| **Use in design** | âœ… YES â€” channel sizing | âŒ NO â€” flood risk assessment only |

Using Q_ML to size a local channel would result in a **massively over-engineered structure** 
that is economically unjustifiable. The rational method with IDF rainfall is the
standards-compliant approach for local drainage design.
""")

    # Recommendations table
    st.subheader("Additional Flood Mitigation Recommendations")
    if risk['safety_factor'] >= 5:
        st.markdown("""
- ğŸ”µ Retention / detention pond upstream of critical infrastructure  
- ğŸ”µ Overflow spillway at least 0.5 m above total design depth  
- ğŸ”µ Real-time flood early-warning system tied to upstream gauge  
- ğŸ”µ Vegetated buffer strips to reduce peak runoff coefficient  
- ğŸ”µ Regular maintenance schedule (debris removal, sediment survey)  
        """)
    else:
        st.markdown("""
- ğŸŸ¡ Standard maintenance schedule (bi-annual inspection)  
- ğŸŸ¡ Freeboard provides adequate buffer for moderate extreme events  
- ğŸŸ¡ Monitor upstream development for changes in runoff coefficient  
        """)
